#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "$ROOT_DIR"

TOOLS_DIR="$ROOT_DIR/.tools"
ZIG_DIR="$TOOLS_DIR/zig"
ZIG_BIN="$ZIG_DIR/zig"

SRC_C="$ROOT_DIR/artifacts/compiler/c/add1_wasm.c"
OUT_WASM="$(mktemp --suffix=.wasm)"
OUT_JS="$ROOT_DIR/artifacts/visuals/wasm/add1_wasm_b64.js"

mkdir -p "$TOOLS_DIR" "$ROOT_DIR/artifacts/visuals/wasm"

if [[ ! -x "$ZIG_BIN" ]]; then
  echo "[build_wasm_add1] zig not found; downloading a local copy (no sudo)"
  TMP="$(mktemp -d)"
  trap 'rm -rf "$TMP" "$OUT_WASM"' EXIT

  curl -L --fail https://ziglang.org/download/index.json -o "$TMP/index.json"
  python3 - <<'PY' "$TMP/index.json" "$TMP/meta.json"
import json, re, sys
idx = json.load(open(sys.argv[1], "r", encoding="utf-8"))
vers = []
for k in idx.keys():
  if k == "master":
    continue
  if re.match(r"^\d+\.\d+\.\d+$", k):
    vers.append(tuple(map(int, k.split("."))))
vers.sort(reverse=True)
if not vers:
  raise SystemExit("no stable zig versions found in index.json")
v = ".".join(map(str, vers[0]))
info = idx[v]
linux = info.get("x86_64-linux")
if not linux:
  raise SystemExit(f"missing x86_64-linux build for zig {v}")
json.dump({"version": v, "tarball": linux["tarball"], "shasum": linux["shasum"]}, open(sys.argv[2], "w", encoding="utf-8"))
print(v)
PY
  VERSION="$(cat "$TMP/meta.json" | python3 -c 'import json,sys; print(json.load(sys.stdin)["version"])')"
  TARBALL="$(cat "$TMP/meta.json" | python3 -c 'import json,sys; print(json.load(sys.stdin)["tarball"])')"
  SHASUM="$(cat "$TMP/meta.json" | python3 -c 'import json,sys; print(json.load(sys.stdin)["shasum"])')"

  echo "[build_wasm_add1] zig version=$VERSION"
  echo "[build_wasm_add1] tarball=$TARBALL"
  curl -L --fail "$TARBALL" -o "$TMP/zig.tar.xz"
  GOT="$(sha256sum "$TMP/zig.tar.xz" | awk '{print $1}')"
  if [[ "$GOT" != "$SHASUM" ]]; then
    echo "[build_wasm_add1] ERROR: sha256 mismatch (got=$GOT expected=$SHASUM)" >&2
    exit 2
  fi

  rm -rf "$ZIG_DIR"
  mkdir -p "$ZIG_DIR"
  tar -xf "$TMP/zig.tar.xz" -C "$ZIG_DIR" --strip-components=1
fi

echo "[build_wasm_add1] compiling $SRC_C â†’ wasm (freestanding)"
"$ZIG_BIN" cc \
  -target wasm32-freestanding \
  -O3 \
  -nostdlib \
  -Wl,--no-entry \
  -Wl,--export=add1 \
  -Wl,--export=add1_i32 \
  -o "$OUT_WASM" \
  "$SRC_C"

WASM_B64="$(base64 -w0 "$OUT_WASM")"

cat >"$OUT_JS" <<EOF
// Self-contained WebAssembly payload (base64) for the extracted \`add1\` example.
// This is compiled from \`artifacts/compiler/c/add1_wasm.c\` (no libc, no main).
//
// Keeping this as base64 avoids \`fetch()\` so the demo works on GitHub Pages *and*
// when opened directly as a local file.
//
// Generated by: scripts/build_wasm_add1.sh

window.CLOSING_THE_LOOP_WASM = window.CLOSING_THE_LOOP_WASM || {}
window.CLOSING_THE_LOOP_WASM.add1_b64 =
  "$WASM_B64"
EOF

echo "[build_wasm_add1] wrote $OUT_JS"

# Keep GitHub Pages docs/ in sync if this repo has it.
REPO_ROOT="$(cd "$ROOT_DIR/.." && pwd)"
if [[ -d "$REPO_ROOT/docs/wasm" ]]; then
  cp -f "$OUT_JS" "$REPO_ROOT/docs/wasm/add1_wasm_b64.js"
  echo "[build_wasm_add1] wrote $REPO_ROOT/docs/wasm/add1_wasm_b64.js"
fi
